<<<<<<< HEAD
setwd("~/Documents/Rug/Computing Science/Thesis/masters-thesis-guntur/source-code")
all_global_data <- read.table("global-dump.txt",
header = TRUE,
sep="\t",
fill=FALSE,
strip.white=TRUE)
View(all_global_data)
View(all_global_data)
# customized plot
panel.cor <- function(x, y, digits=2, cex.cor)
{
usr <- par("usr"); on.exit(par(usr))
par(usr = c(0, 1, 0, 1))
r <- abs(cor(x, y))
txt <- format(c(r, 0.123456789), digits=digits)[1]
test <- cor.test(x,y)
Signif <- ifelse(round(test$p.value,3)<0.001,"p<0.001",paste("p=",round(test$p.value,3)))
text(0.5, 0.25, paste("r=",txt))
text(.5, .75, Signif)
}
panel.smooth<-function (x, y, col = "blue", bg = NA, pch = 18,
cex = 0.8, col.smooth = "red", span = 2/3, iter = 3, ...)
{
points(x, y, pch = pch, col = col, bg = bg, cex = cex)
ok <- is.finite(x) & is.finite(y)
if (any(ok))
lines(stats::lowess(x[ok], y[ok], f = span, iter = iter),
col = col.smooth, ...)
}
panel.hist <- function(x, ...)
{
usr <- par("usr"); on.exit(par(usr))
par(usr = c(usr[1:2], 0, 1.5) )
h <- hist(x, plot = FALSE)
breaks <- h$breaks; nB <- length(breaks)
y <- h$counts; y <- y/max(y)
rect(breaks[-nB], 0, breaks[-1], y, col="cyan", ...)
}
pairs(all_global_data,
lower.panel=panel.smooth, upper.panel=panel.cor,diag.panel=panel.hist)
View(all_global_data)
View(all_global_data)
global_data <- all_global_data[, -9]
View(global_data)
View(global_data)
pairs(all_global_data,
lower.panel=panel.smooth, upper.panel=panel.cor,diag.panel=panel.hist)
pairs(global_data,
lower.panel=panel.smooth, upper.panel=panel.cor,diag.panel=panel.hist)
# Grouped Bar Plot
counts <- table(mtcars$vs, mtcars$gear)
barplot(counts, main="Car Distribution by Gears and VS",
xlab="Number of Gears", col=c("darkblue","red"),
legend = rownames(counts), beside=TRUE)
View(global_data)
counts
View(all_global_data)
View(all_global_data)
counts <- table(mtcars$vs, mtcars$gear)
barplot(counts, main="Car Distribution by Gears and VS",
xlab="Number of Gears" , #col=c("darkblue","red"),
legend = rownames(counts), beside=TRUE)
foo <- subset(all_global_data, LOC!="g")
View(foo)
View(foo)
foo <- subset(foo, LOC!="p")
foo <- subset(foo, LOC!="h")
population <- read.table("population.txt",
header = TRUE,
sep="\t",
#col.names=c("ap", "pr","au", "gt",
#            "rms", "pklv", "rssi", "snr", "loc"),
fill=FALSE,
strip.white=TRUE)
# read data
population <- read.table("population.txt",
header = TRUE,
sep="\t",
#col.names=c("ap", "pr","au", "gt",
#            "rms", "pklv", "rssi", "snr", "loc"),
fill=FALSE,
strip.white=TRUE)
View(population)
View(population)
barplot(population, main="Car Distribution by Gears and VS",
xlab="Number of Gears" , #col=c("darkblue","red"),
legend = rownames(counts), beside=TRUE)
row.names()
row.names(population)
row.names(population) <- ["head count", "device count"]
row.names(population) <- ("head count", "device count")
row.names(population) <- c("head count", "device count")
barplot(population, main="Car Distribution by Gears and VS",
xlab="Number of Gears" , #col=c("darkblue","red"),
legend = rownames(counts), beside=TRUE)
counts
barplot(t(as.matrix(population)), beside=TRUE)
row.names(population) <- c("device count", "head count")
t(as.matrix(population)
;
t(as.matrix(population)
;
foo <- t(as.matrix(population)
)
View(foo)
as.matrix(population)
barplot(as.matrix(population), beside=TRUE)
# read data
population <- read.table("population.txt",
header = TRUE,
sep="\t",
#col.names=c("ap", "pr","au", "gt",
#            "rms", "pklv", "rssi", "snr", "loc"),
fill=FALSE,
strip.white=TRUE)
barplot(as.matrix(population), beside=TRUE)
?barplot
barplot(as.matrix(population), beside=TRUE, legend.text = rownames(population))
row.names(population) <- c("device count", "head count")
barplot(as.matrix(population), beside=TRUE, legend.text = rownames(population))
barplot(as.matrix(population), beside=FALSE, legend.text = rownames(population))
TRUE
barplot(as.matrix(population), beside=TRUE, legend.text = rownames(population))
barplot(as.matrix(population), beside=TRUE, legend.text = rownames(population), ylim = 300)
barplot(as.matrix(population), beside=TRUE, legend.text = rownames(population))
barplot(as.matrix(population), beside=TRUE, legend.text = rownames(population), args.legend = "topleft")
barplot(as.matrix(population), beside=TRUE, legend.text = rownames(population), args.legend = list(x="topleft")
barplot(as.matrix(population), beside=TRUE, legend.text = rownames(population), args.legend = list(x="topleft")
t(as.matrix(population)
)
barplot(as.matrix(population), beside=TRUE, legend.text = rownames(population), args.legend = list(x="topleft"))
boxplot(mpg~cyl,data=mtcars, main="Car Milage Data",
xlab="Number of Cylinders", ylab="Miles Per Gallon")
mpg~cyl
print(mpg~cyl)
a = mpg~cyl
mpg
cyl
mtcars
?boxplot
View(all_global_data)
boxplot(dc~loc,data=all_global_data, main="Car Milage Data",
xlab="Number of Cylinders", ylab="Miles Per Gallon")
boxplot(DC~LOC,data=all_global_data, main="Car Milage Data",
xlab="Number of Cylinders", ylab="Miles Per Gallon")
boxplot(DC~LOC,data=all_global_data, main="",
xlab="location", ylab="device count")
boxplot(DC~LOC,data=all_global_data, main="",
xlab="location", ylab="device count", notch=TRUE)
boxplot(DC~LOC,data=all_global_data, main="",
xlab="location", ylab="device count")
foo <- all_global_data
foo$LOC <- factor(foo$LOC, levels=c("r", "h", "p", "g"))
boxplot(DC~LOC,data=foo, main="",
xlab="location", ylab="device count")
View(foo)
View(foo)
foo[LOC == "g"] <- "grotemarkt"
foo[foo == "g"] <- "grotemarkt"
foo[foo == "g"] <- "grotemarkt"
foo[foo == "g"] <- "grotemarkt"
foo[foo == "g"] <- c("grotemarkt")
foo[foo == ""] <- c("grotemarkt")
foo[foo == "r"] <- c("grotemarkt")
foo <- all_global_data
foo$LOC <- factor(foo$LOC, levels=c("r", "h", "p", "g"))
foo[foo == "r"] <- c("grotemarkt")
foo[foo == ""] <- "grotemarkt"
foo <- all_global_data
foo$LOC <- factor(foo$LOC, levels=c("r", "h", "p", "g"))
boxplot(DC~LOC,data=foo, main="",
xlab="location", ylab="device count")
boxplot(DC~LOC,data=foo, main="",
xlab="location", ylab="device count")
stripchart(DC ~ LOC, vertical = TRUE, data = foo,
method = "jitter", add = TRUE, pch = 20, col = 'blue')
text(x=fivenum(X), labels =fivenum(X), y=1.25)
boxplot(DC~LOC,data=foo, main="",
xlab="location", ylab="device count", names=c("remote", "home", "paddepoel", "grotemarkt"))
Tukeys_five <- c("Min","Q1","Med","Q3","Max")
# this will create the wide data.table
lengthBySpecies <- foo[,as.list(fivenum(DC)), by = LOC]
# and you can rename the columns from V1, ..., V5 to something nicer
setnames(lengthBySpecies, paste0('V',1:5), Tukeys_five)
lengthBySpecies
lengthBySpecies <- foo[,as.list(fivenum(DC)), by = LOC]
lengthBySpecies <- foo[,as.list(fivenum(DC)), by = LOC]
lengthBySpecies <- foo[,as.list(fivenum(DC))]
lengthBySpecies <- foo[,as.list(fivenum(foo$DC))]
IRIS <- data.table(foo)
library(data.table)
library(data.table)
Tukeys_five <- c("Min","Q1","Med","Q3","Max")
IRIS <- data.table(foo)
library(data.table)
install.packages("data.table")
library(data.table)
Tukeys_five <- c("Min","Q1","Med","Q3","Max")
IRIS <- data.table(foo)
lengthBySpecies <- IRIS[,as.list(fivenum(DC)), by = LOC]
setnames(lengthBySpecies, paste0('V',1:5), Tukeys_five)
lengthBySpecies
boxplot(DC~LOC,data=foo, main="",
xlab="location", ylab="device count", names=c("remote", "home", "paddepoel", "grotemarkt"),
outline=FALSE)
boxplot(DC~LOC,data=foo, main="",
xlab="location", ylab="device count", names=c("remote", "home", "paddepoel", "grotemarkt"),
outline=FALSE, ylim=c(0,100))
boxplot(DC~LOC,data=foo, main="",
xlab="location", ylab="device count", names=c("remote", "home", "paddepoel", "grotemarkt"),
outline=FALSE, ylim=c(0,255))
library(data.table)
Tukeys_five <- c("Min","Q1","Med","Q3","Max")
IRIS <- data.table(foo)
# this will create the wide data.table
lengthBySpecies <- IRIS[,as.list(fivenum(HC)), by = LOC]
# and you can rename the columns from V1, ..., V5 to something nicer
setnames(lengthBySpecies, paste0('V',1:5), Tukeys_five)
lengthBySpecies
boxplot(HC~LOC,data=foo, main="",
xlab="location", ylab="device count", names=c("remote", "home", "paddepoel", "grotemarkt"),
outline=FALSE, ylim=c(0,255))
boxplot(HC~LOC,data=foo, main="",
xlab="location", ylab="device count", names=c("remote", "home", "paddepoel", "grotemarkt"),
outline=TRUE, ylim=c(0,255))
boxplot(DC~LOC,data=foo, main="",
xlab="location", ylab="device count", names=c("remote", "home", "paddepoel", "grotemarkt"),
outline=TRUE, ylim=c(0,255))
=======
tuneResult <- tune(svm, pr~.,  data=phone_data_pr,
ranges = list(epsilon = seq(0,0.2,0.01), cost = (1:10)))
tuneResult <- tune(svm, pr~.,  data=phone_data_pr,
ranges = list(epsilon = seq(0,1,0.1), cost = (1:10)))
tuneResult
crossval.pr <- function(number){
set.seed(100)
folds <- createFolds(phone_data_pr[,c("pr")], k = number,
list = TRUE, returnTrain = FALSE)
fit_control <- trainControl(method = "repeatedcv", number = 10, repeats = 10)
svm.accuracies <- c()
for (i in 1:number) {
# model <- train(pr~., data=phone_data_pr[-folds[[i]],],
#                method="leapForward", tuneGrid = data.frame(nvmax=4),
#                trControl=fit_control)
# model <- train(pr~., data=phone_data_pr[-folds[[i]],], method="knn",
#                trControl=fit_control, tuneGrid = data.frame(k=9))
model <- svm(pr~., phone_data_pr[-folds[[i]],], eps=0, cost=2,
type="eps-regression")
print(model)
print(i)
predictions <- predict(model, phone_data_pr[folds[[i]],])
# error <- sqrt(mean((phone_data_pr[folds[[i]],]$pr - predictions)^2))
error <- mean(abs(phone_data_pr[folds[[i]],]$pr - predictions))
svm.accuracies = append(error, svm.accuracies)
}
return(svm.accuracies)
}
total <- crossval.pr(10)
mean(total)
sd(total)
crossval.pr <- function(number){
set.seed(100)
folds <- createFolds(phone_data_pr[,c("pr")], k = number,
list = TRUE, returnTrain = FALSE)
fit_control <- trainControl(method = "repeatedcv", number = 10, repeats = 10)
svm.accuracies <- c()
for (i in 1:number) {
# model <- train(pr~., data=phone_data_pr[-folds[[i]],],
#                method="leapForward", tuneGrid = data.frame(nvmax=4),
#                trControl=fit_control)
# model <- train(pr~., data=phone_data_pr[-folds[[i]],], method="knn",
#                trControl=fit_control, tuneGrid = data.frame(k=9))
model <- svm(pr~., phone_data_pr[-folds[[i]],], eps=0, cost=1,
type="eps-regression")
print(model)
print(i)
predictions <- predict(model, phone_data_pr[folds[[i]],])
# error <- sqrt(mean((phone_data_pr[folds[[i]],]$pr - predictions)^2))
error <- mean(abs(phone_data_pr[folds[[i]],]$pr - predictions))
svm.accuracies = append(error, svm.accuracies)
}
return(svm.accuracies)
}
total <- crossval.pr(10)
mean(total)
sd(total)
crossval.pr <- function(number){
set.seed(100)
folds <- createFolds(phone_data_pr[,c("pr")], k = number,
list = TRUE, returnTrain = FALSE)
fit_control <- trainControl(method = "repeatedcv", number = 10, repeats = 10)
svm.accuracies <- c()
for (i in 1:number) {
# model <- train(pr~., data=phone_data_pr[-folds[[i]],],
#                method="leapForward", tuneGrid = data.frame(nvmax=4),
#                trControl=fit_control)
# model <- train(pr~., data=phone_data_pr[-folds[[i]],], method="knn",
#                trControl=fit_control, tuneGrid = data.frame(k=9))
model <- svm(pr~., phone_data_pr[-folds[[i]],], eps=0, cost=2,
type="eps-regression")
print(model)
print(i)
predictions <- predict(model, phone_data_pr[folds[[i]],])
# error <- sqrt(mean((phone_data_pr[folds[[i]],]$pr - predictions)^2))
error <- mean(abs(phone_data_pr[folds[[i]],]$pr - predictions))
svm.accuracies = append(error, svm.accuracies)
}
return(svm.accuracies)
}
total <- crossval.pr(10)
mean(total)
sd(total)
crossval.pr <- function(number){
set.seed(100)
folds <- createFolds(phone_data_pr[,c("pr")], k = number,
list = TRUE, returnTrain = FALSE)
fit_control <- trainControl(method = "repeatedcv", number = 10, repeats = 10)
svm.accuracies <- c()
for (i in 1:number) {
# model <- train(pr~., data=phone_data_pr[-folds[[i]],],
#                method="leapForward", tuneGrid = data.frame(nvmax=4),
#                trControl=fit_control)
# model <- train(pr~., data=phone_data_pr[-folds[[i]],], method="knn",
#                trControl=fit_control, tuneGrid = data.frame(k=9))
model <- svm(pr~., phone_data_pr[-folds[[i]],], eps=0, cost=1,
type="eps-regression")
print(model)
print(i)
predictions <- predict(model, phone_data_pr[folds[[i]],])
# error <- sqrt(mean((phone_data_pr[folds[[i]],]$pr - predictions)^2))
error <- mean(abs(phone_data_pr[folds[[i]],]$pr - predictions))
svm.accuracies = append(error, svm.accuracies)
}
return(svm.accuracies)
}
total <- crossval.pr(10)
mean(total)
sd(total)
crossval.pr <- function(number){
set.seed(100)
folds <- createFolds(phone_data_pr[,c("pr")], k = number,
list = TRUE, returnTrain = FALSE)
fit_control <- trainControl(method = "repeatedcv", number = 10, repeats = 10)
svm.accuracies <- c()
for (i in 1:number) {
# model <- train(pr~., data=phone_data_pr[-folds[[i]],],
#                method="leapForward", tuneGrid = data.frame(nvmax=4),
#                trControl=fit_control)
# model <- train(pr~., data=phone_data_pr[-folds[[i]],], method="knn",
#                trControl=fit_control, tuneGrid = data.frame(k=9))
model <- svm(pr~., phone_data_pr[-folds[[i]],], eps=0.1, cost=1,
type="eps-regression")
print(model)
print(i)
predictions <- predict(model, phone_data_pr[folds[[i]],])
# error <- sqrt(mean((phone_data_pr[folds[[i]],]$pr - predictions)^2))
error <- mean(abs(phone_data_pr[folds[[i]],]$pr - predictions))
svm.accuracies = append(error, svm.accuracies)
}
return(svm.accuracies)
}
total <- crossval.pr(10)
mean(total)
sd(total)
crossval.pr <- function(number){
set.seed(100)
folds <- createFolds(phone_data_pr[,c("pr")], k = number,
list = TRUE, returnTrain = FALSE)
fit_control <- trainControl(method = "repeatedcv", number = 10, repeats = 10)
svm.accuracies <- c()
for (i in 1:number) {
# model <- train(pr~., data=phone_data_pr[-folds[[i]],],
#                method="leapForward", tuneGrid = data.frame(nvmax=4),
#                trControl=fit_control)
# model <- train(pr~., data=phone_data_pr[-folds[[i]],], method="knn",
#                trControl=fit_control, tuneGrid = data.frame(k=9))
model <- svm(pr~., phone_data_pr[-folds[[i]],], eps=0.5, cost=1,
type="eps-regression")
print(model)
print(i)
predictions <- predict(model, phone_data_pr[folds[[i]],])
# error <- sqrt(mean((phone_data_pr[folds[[i]],]$pr - predictions)^2))
error <- mean(abs(phone_data_pr[folds[[i]],]$pr - predictions))
svm.accuracies = append(error, svm.accuracies)
}
return(svm.accuracies)
}
total <- crossval.pr(10)
mean(total)
sd(total)
crossval.pr <- function(number){
set.seed(100)
folds <- createFolds(phone_data_pr[,c("pr")], k = number,
list = TRUE, returnTrain = FALSE)
fit_control <- trainControl(method = "repeatedcv", number = 10, repeats = 10)
svm.accuracies <- c()
for (i in 1:number) {
# model <- train(pr~., data=phone_data_pr[-folds[[i]],],
#                method="leapForward", tuneGrid = data.frame(nvmax=4),
#                trControl=fit_control)
# model <- train(pr~., data=phone_data_pr[-folds[[i]],], method="knn",
#                trControl=fit_control, tuneGrid = data.frame(k=9))
model <- svm(pr~., phone_data_pr[-folds[[i]],], eps=1, cost=1,
type="eps-regression")
print(model)
print(i)
predictions <- predict(model, phone_data_pr[folds[[i]],])
# error <- sqrt(mean((phone_data_pr[folds[[i]],]$pr - predictions)^2))
error <- mean(abs(phone_data_pr[folds[[i]],]$pr - predictions))
svm.accuracies = append(error, svm.accuracies)
}
return(svm.accuracies)
}
total <- crossval.pr(10)
mean(total)
sd(total)
crossval.pr <- function(number){
set.seed(100)
folds <- createFolds(phone_data_pr[,c("pr")], k = number,
list = TRUE, returnTrain = FALSE)
fit_control <- trainControl(method = "repeatedcv", number = 10, repeats = 10)
svm.accuracies <- c()
for (i in 1:number) {
# model <- train(pr~., data=phone_data_pr[-folds[[i]],],
#                method="leapForward", tuneGrid = data.frame(nvmax=4),
#                trControl=fit_control)
# model <- train(pr~., data=phone_data_pr[-folds[[i]],], method="knn",
#                trControl=fit_control, tuneGrid = data.frame(k=9))
model <- svm(pr~., phone_data_pr[-folds[[i]],], eps=0, cost=1,
type="eps-regression")
print(model)
print(i)
predictions <- predict(model, phone_data_pr[folds[[i]],])
# error <- sqrt(mean((phone_data_pr[folds[[i]],]$pr - predictions)^2))
error <- mean(abs(phone_data_pr[folds[[i]],]$pr - predictions))
svm.accuracies = append(error, svm.accuracies)
}
return(svm.accuracies)
}
total <- crossval.pr(10)
mean(total)
sd(total)
crossval.pr <- function(number){
set.seed(100)
folds <- createFolds(phone_data_pr[,c("pr")], k = number,
list = TRUE, returnTrain = FALSE)
fit_control <- trainControl(method = "repeatedcv", number = 10, repeats = 10)
svm.accuracies <- c()
for (i in 1:number) {
# model <- train(pr~., data=phone_data_pr[-folds[[i]],],
#                method="leapForward", tuneGrid = data.frame(nvmax=4),
#                trControl=fit_control)
# model <- train(pr~., data=phone_data_pr[-folds[[i]],], method="knn",
#                trControl=fit_control, tuneGrid = data.frame(k=9))
model <- svm(pr~., phone_data_pr[-folds[[i]],], eps=0.01, cost=1,
type="eps-regression")
print(model)
print(i)
predictions <- predict(model, phone_data_pr[folds[[i]],])
# error <- sqrt(mean((phone_data_pr[folds[[i]],]$pr - predictions)^2))
error <- mean(abs(phone_data_pr[folds[[i]],]$pr - predictions))
svm.accuracies = append(error, svm.accuracies)
}
return(svm.accuracies)
}
total <- crossval.pr(10)
mean(total)
sd(total)
crossval.pr <- function(number){
set.seed(100)
folds <- createFolds(phone_data_pr[,c("pr")], k = number,
list = TRUE, returnTrain = FALSE)
fit_control <- trainControl(method = "repeatedcv", number = 10, repeats = 10)
svm.accuracies <- c()
for (i in 1:number) {
# model <- train(pr~., data=phone_data_pr[-folds[[i]],],
#                method="leapForward", tuneGrid = data.frame(nvmax=4),
#                trControl=fit_control)
# model <- train(pr~., data=phone_data_pr[-folds[[i]],], method="knn",
#                trControl=fit_control, tuneGrid = data.frame(k=9))
model <- svm(pr~., phone_data_pr[-folds[[i]],], eps=0, cost=1,
type="eps-regression")
print(model)
print(i)
predictions <- predict(model, phone_data_pr[folds[[i]],])
# error <- sqrt(mean((phone_data_pr[folds[[i]],]$pr - predictions)^2))
error <- mean(abs(phone_data_pr[folds[[i]],]$pr - predictions))
svm.accuracies = append(error, svm.accuracies)
}
return(svm.accuracies)
}
total <- crossval.pr(10)
mean(total)
sd(total)
crossval.pr <- function(number){
set.seed(100)
folds <- createFolds(phone_data_pr[,c("pr")], k = number,
list = TRUE, returnTrain = FALSE)
fit_control <- trainControl(method = "repeatedcv", number = 10, repeats = 10)
svm.accuracies <- c()
for (i in 1:number) {
# model <- train(pr~., data=phone_data_pr[-folds[[i]],],
#                method="leapForward", tuneGrid = data.frame(nvmax=4),
#                trControl=fit_control)
# model <- train(pr~., data=phone_data_pr[-folds[[i]],], method="knn",
#                trControl=fit_control, tuneGrid = data.frame(k=9))
model <- svm(pr~., phone_data_pr[-folds[[i]],], eps=0, cost=10,
type="eps-regression")
print(model)
print(i)
predictions <- predict(model, phone_data_pr[folds[[i]],])
# error <- sqrt(mean((phone_data_pr[folds[[i]],]$pr - predictions)^2))
error <- mean(abs(phone_data_pr[folds[[i]],]$pr - predictions))
svm.accuracies = append(error, svm.accuracies)
}
return(svm.accuracies)
}
total <- crossval.pr(10)
mean(total)
sd(total)
crossval.pr <- function(number){
set.seed(100)
folds <- createFolds(phone_data_pr[,c("pr")], k = number,
list = TRUE, returnTrain = FALSE)
fit_control <- trainControl(method = "repeatedcv", number = 10, repeats = 10)
svm.accuracies <- c()
for (i in 1:number) {
# model <- train(pr~., data=phone_data_pr[-folds[[i]],],
#                method="leapForward", tuneGrid = data.frame(nvmax=4),
#                trControl=fit_control)
# model <- train(pr~., data=phone_data_pr[-folds[[i]],], method="knn",
#                trControl=fit_control, tuneGrid = data.frame(k=9))
model <- svm(pr~., phone_data_pr[-folds[[i]],], eps=0, cost=1,
type="eps-regression")
print(model)
print(i)
predictions <- predict(model, phone_data_pr[folds[[i]],])
# error <- sqrt(mean((phone_data_pr[folds[[i]],]$pr - predictions)^2))
error <- mean(abs(phone_data_pr[folds[[i]],]$pr - predictions))
svm.accuracies = append(error, svm.accuracies)
}
return(svm.accuracies)
}
total <- crossval.pr(10)
mean(total)
sd(total)
crossval.pr <- function(number){
set.seed(100)
folds <- createFolds(phone_data_pr[,c("pr")], k = number,
list = TRUE, returnTrain = FALSE)
fit_control <- trainControl(method = "repeatedcv", number = 10, repeats = 10)
svm.accuracies <- c()
for (i in 1:number) {
# model <- train(pr~., data=phone_data_pr[-folds[[i]],],
#                method="leapForward", tuneGrid = data.frame(nvmax=4),
#                trControl=fit_control)
# model <- train(pr~., data=phone_data_pr[-folds[[i]],], method="knn",
#                trControl=fit_control, tuneGrid = data.frame(k=9))
model <- svm(pr~., phone_data_pr[-folds[[i]],], eps=0, cost=1,
type="eps-regression")
print(model)
print(i)
predictions <- predict(model, phone_data_pr[folds[[i]],])
error <- sqrt(mean((phone_data_pr[folds[[i]],]$pr - predictions)^2))
# error <- mean(abs(phone_data_pr[folds[[i]],]$pr - predictions))
svm.accuracies = append(error, svm.accuracies)
}
return(svm.accuracies)
}
total <- crossval.pr(10)
mean(total)
sd(total)
crossval.pr <- function(number){
set.seed(100)
folds <- createFolds(phone_data_pr[,c("pr")], k = number,
list = TRUE, returnTrain = FALSE)
fit_control <- trainControl(method = "repeatedcv", number = 10, repeats = 10)
svm.accuracies <- c()
for (i in 1:number) {
# model <- train(pr~., data=phone_data_pr[-folds[[i]],],
#                method="leapForward", tuneGrid = data.frame(nvmax=4),
#                trControl=fit_control)
model <- train(pr~., data=phone_data_pr[-folds[[i]],], method="knn",
trControl=fit_control, tuneGrid = data.frame(k=9))
# model <- svm(pr~., phone_data_pr[-folds[[i]],], eps=0, cost=1,
#             type="eps-regression")
print(model)
print(i)
predictions <- predict(model, phone_data_pr[folds[[i]],])
error <- sqrt(mean((phone_data_pr[folds[[i]],]$pr - predictions)^2))
# error <- mean(abs(phone_data_pr[folds[[i]],]$pr - predictions))
svm.accuracies = append(error, svm.accuracies)
}
return(svm.accuracies)
}
total <- crossval.pr(10)
mean(total)
sd(total)
tuneResult
crossval.pr <- function(number){
set.seed(100)
folds <- createFolds(phone_data_pr[,c("pr")], k = number,
list = TRUE, returnTrain = FALSE)
fit_control <- trainControl(method = "repeatedcv", number = 10, repeats = 10)
svm.accuracies <- c()
for (i in 1:number) {
# model <- train(pr~., data=phone_data_pr[-folds[[i]],],
#                method="leapForward", tuneGrid = data.frame(nvmax=4),
#                trControl=fit_control)
# model <- train(pr~., data=phone_data_pr[-folds[[i]],], method="knn",
#                trControl=fit_control, tuneGrid = data.frame(k=9))
model <- svm(pr~., phone_data_pr[-folds[[i]],], eps=0, cost=4,
type="eps-regression")
print(model)
print(i)
predictions <- predict(model, phone_data_pr[folds[[i]],])
error <- sqrt(mean((phone_data_pr[folds[[i]],]$pr - predictions)^2))
# error <- mean(abs(phone_data_pr[folds[[i]],]$pr - predictions))
svm.accuracies = append(error, svm.accuracies)
}
return(svm.accuracies)
}
total <- crossval.pr(10)
mean(total)
sd(total)
crossval.pr <- function(number){
set.seed(100)
folds <- createFolds(phone_data_pr[,c("pr")], k = number,
list = TRUE, returnTrain = FALSE)
fit_control <- trainControl(method = "repeatedcv", number = 10, repeats = 10)
svm.accuracies <- c()
for (i in 1:number) {
# model <- train(pr~., data=phone_data_pr[-folds[[i]],],
#                method="leapForward", tuneGrid = data.frame(nvmax=4),
#                trControl=fit_control)
# model <- train(pr~., data=phone_data_pr[-folds[[i]],], method="knn",
#                trControl=fit_control, tuneGrid = data.frame(k=9))
model <- svm(pr~., phone_data_pr[-folds[[i]],], eps=0, cost=4,
type="eps-regression")
print(model)
print(i)
predictions <- predict(model, phone_data_pr[folds[[i]],])
# error <- sqrt(mean((phone_data_pr[folds[[i]],]$pr - predictions)^2))
error <- mean(abs(phone_data_pr[folds[[i]],]$pr - predictions))
svm.accuracies = append(error, svm.accuracies)
}
return(svm.accuracies)
}
total <- crossval.pr(10)
mean(total)
sd(total)
set.seed(100)
tuning_params <- expand.grid(k=seq(1,20,1))
knn.pr <- train(pr~., data=phone_data_pr, method="knn",
trControl=fit_control, tuneGrid = tuning_params)
knn.pr
crossval.pr <- function(number){
set.seed(100)
folds <- createFolds(phone_data_pr[,c("pr")], k = number,
list = TRUE, returnTrain = FALSE)
fit_control <- trainControl(method = "repeatedcv", number = 10, repeats = 10)
svm.accuracies <- c()
for (i in 1:number) {
# model <- train(pr~., data=phone_data_pr[-folds[[i]],],
#                method="leapForward", tuneGrid = data.frame(nvmax=4),
#                trControl=fit_control)
model <- train(pr~., data=phone_data_pr[-folds[[i]],], method="knn",
trControl=fit_control, tuneGrid = data.frame(k=8))
# model <- svm(pr~., phone_data_pr[-folds[[i]],], eps=0, cost=4,
#             type="eps-regression")
print(model)
print(i)
predictions <- predict(model, phone_data_pr[folds[[i]],])
# error <- sqrt(mean((phone_data_pr[folds[[i]],]$pr - predictions)^2))
error <- mean(abs(phone_data_pr[folds[[i]],]$pr - predictions))
svm.accuracies = append(error, svm.accuracies)
}
return(svm.accuracies)
}
total <- crossval.pr(10)
mean(total)
sd(total)
set.seed(100)
tuning_params <- expand.grid(k=seq(1,20,1))
knn.pr <- train(pr~., data=phone_data_pr, method="knn",
trControl=fit_control, tuneGrid = tuning_params)
knn.pr
crossval.pr <- function(number){
set.seed(100)
folds <- createFolds(phone_data_pr[,c("pr")], k = number,
list = TRUE, returnTrain = FALSE)
fit_control <- trainControl(method = "repeatedcv", number = 10, repeats = 10)
svm.accuracies <- c()
for (i in 1:number) {
# model <- train(pr~., data=phone_data_pr[-folds[[i]],],
#                method="leapForward", tuneGrid = data.frame(nvmax=4),
#                trControl=fit_control)
model <- train(pr~., data=phone_data_pr[-folds[[i]],], method="knn",
trControl=fit_control, tuneGrid = data.frame(k=8))
# model <- svm(pr~., phone_data_pr[-folds[[i]],], eps=0, cost=4,
#             type="eps-regression")
print(model)
print(i)
predictions <- predict(model, phone_data_pr[folds[[i]],])
# error <- sqrt(mean((phone_data_pr[folds[[i]],]$pr - predictions)^2))
error <- mean(abs(phone_data_pr[folds[[i]],]$pr - predictions))
svm.accuracies = append(error, svm.accuracies)
}
return(svm.accuracies)
}
total <- crossval.pr(10)
mean(total)
sd(total)
crossval <- function(number){
set.seed(100)
folds <- createFolds(phone_data_gt[,c("gt")], k = number,
list = TRUE, returnTrain = FALSE)
fit_control <- trainControl(method = "repeatedcv", number = 10, repeats = 10)
svm.accuracies <- c()
for (i in 1:number) {
# model <- train(gt~., data=phone_data_gt[-folds[[i]],],
#                method="leapForward", tuneGrid = data.frame(nvmax=4),
#                trControl=fit_control)
# model <- train(gt~., data=phone_data_gt[-folds[[i]],], method="knn",
#                trControl=fit_control, tuneGrid = data.frame(k=8))
model <- svm(gt~., phone_data_gt[-folds[[i]],], eps=0, cost=1,
type="eps-regression")
print(model)
print(i)
predictions <- predict(model, phone_data_gt[folds[[i]],])
error <- sqrt(mean((phone_data_gt[folds[[i]],]$gt - predictions)^2))
# error <- mean(abs(phone_data_gt[folds[[i]],]$gt - predictions))
svm.accuracies = append(error, svm.accuracies)
}
print(phone_data_gt[folds[[10]],]$gt)
print(predictions)
return(svm.accuracies)
}
total <- crossval(10)
View(phone_data_gt)
View(phone_data_gt)
>>>>>>> deb4eee798046ff3050e2fdc49aff179daa28237
