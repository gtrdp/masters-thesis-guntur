cost = 2000,
kernel="radial",
type="eps-regression")
mean(svm.accuracy)
# k-fold cross validation function
crossval.svm <- function(k = 10, epsilon = 0.1, cost = 1, coef0 = 0, nu=0, kernel="radial",
type="eps-regression", data="gt"){
library(caret)
library(e1071)
if (data=="gt") {
data = phone_data_gt
set.seed(100)
folds <- createFolds(phone_data_gt[,c("gt")], k = k,
list = TRUE, returnTrain = FALSE)
} else {
data = phone_data_pr
set.seed(100)
folds <- createFolds(phone_data_pr[,c("pr")], k = k,
list = TRUE, returnTrain = FALSE)
}
svm.accuracies <- c()
for (i in 1:10) {
if (type=="eps-regression") {
model <- svm(gt~., data[-folds[[i]],],
epsilon=epsilon,
cost=cost,
coef0=coef0,
type=type,
kernel=kernel
)
} else {
model <- svm(gt~., data[-folds[[i]],],
nu=nu,
cost=cost,
coef0=coef0,
type=type,
kernel=kernel
)
}
predictions <- predict(model, phone_data_gt[-folds[[i]],])
rmse <- sqrt(mean((phone_data_gt[-folds[[i]],]$gt - predictions)^2))
svm.accuracies = append(rmse, svm.accuracies)
}
return(svm.accuracies)
}
svm.accuracy <- crossval.svm(k = 10,
epsilon = 0.1,
cost = 2000,
kernel="radial",
type="eps-regression")
mean(svm.accuracy)
svm.accuracy <- crossval.svm(k = 10,
epsilon = 0.1,
cost = 3000,
kernel="radial",
type="eps-regression")
mean(svm.accuracy)
svm.accuracy <- crossval.svm(k = 10,
epsilon = 0.1,
cost = 10000,
kernel="radial",
type="eps-regression")
mean(svm.accuracy)
svm.accuracy <- crossval.svm(k = 10,
epsilon = 0.1,
cost = 100000,
kernel="radial",
type="eps-regression")
mean(svm.accuracy)
set.seed(100)
tuneResult.eps.rad.gt <- tune(svm, gt~.,  data=phone_data_gt,
ranges = list(epsilon = seq(0,1,0.1), cost = (1:10),
kernel="radial", type="eps-regression"),
tunecontrol=tune_control)
svm.accuracy <- crossval.svm(k = 10,
epsilon = tuneResult.eps.linear.gt$best.parameters$epsilon,
cost = tuneResult.eps.linear.gt$best.parameters$cost,
kernel = "radial",
type = "eps-regression")
mean(svm.accuracy)
svm.accuracy <- crossval.svm(k = 10,
epsilon = tuneResult.eps.linear.gt$best.parameters$epsilon,
cost = tuneResult.eps.linear.gt$best.parameters$cost,
kernel = "linear",
type = "eps-regression")
mean(svm.accuracy)
svm.accuracy <- crossval.svm(k = 10,
epsilon = tuneResult.eps.rad.gt$best.parameters$epsilon,
cost = tuneResult.eps.rad.gt$best.parameters$cost,
kernel = "radial",
type = "eps-regression")
mean(svm.accuracy)
svm.accuracy <- crossval.svm(k = 10,
epsilon = tuneResult.eps.sig.gt$best.parameters$epsilon,
cost = tuneResult.eps.sig.gt$best.parameters$cost,
kernel = "sigmoid",
coef0=tuneResult.eps.sig.gt$best.parameters$coef0,
type = "eps-regression")
mean(svm.accuracy)
svm.accuracy <- crossval.svm(k = 10,
nu = tuneResult.nu.sig.gt$best.parameters$nu,
cost = tuneResult.nu.sig.gt$best.parameters$cost,
kernel = "linear",
type = "nu-regression")
mean(svm.accuracy)
svm.accuracy <- crossval.svm(k = 10,
nu = tuneResult.nu.rad.gt$best.parameters$nu,
cost = tuneResult.nu.rad.gt$best.parameters$cost,
kernel = "radial",
type = "nu-regression")
mean(svm.accuracy)
svm.accuracy <- crossval.svm(k = 10,
nu = tuneResult.nu.sig.gt$best.parameters$nu,
cost = tuneResult.nu.sig.gt$best.parameters$cost,
kernel = "sigmoid",
coef0=tuneResult.nu.sig.gt$best.parameters$coef0,
type = "nu-regression")
mean(svm.accuracy)
svm.accuracy <- crossval.svm(k = 10,
epsilon = tuneResult.eps.linear.pr$best.parameters$epsilon,
cost = tuneResult.eps.linear.pr$best.parameters$cost,
kernel = "linear",
type = "eps-regression")
mean(svm.accuracy)
# k-fold cross validation function
crossval.svm <- function(k = 10, epsilon = 0.1, cost = 1, coef0 = 0, nu=0, kernel="radial",
type="eps-regression", data="gt"){
library(caret)
library(e1071)
if (data=="gt") {
data = phone_data_gt
set.seed(100)
folds <- createFolds(phone_data_gt[,c("gt")], k = k,
list = TRUE, returnTrain = FALSE)
formula <- gt~.
} else {
data = phone_data_pr
set.seed(100)
folds <- createFolds(phone_data_pr[,c("pr")], k = k,
list = TRUE, returnTrain = FALSE)
formula <- pr~.
}
svm.accuracies <- c()
for (i in 1:10) {
if (type=="eps-regression") {
model <- svm(formula, data[-folds[[i]],],
epsilon=epsilon,
cost=cost,
coef0=coef0,
type=type,
kernel=kernel
)
} else {
model <- svm(formula, data[-folds[[i]],],
nu=nu,
cost=cost,
coef0=coef0,
type=type,
kernel=kernel
)
}
predictions <- predict(model, phone_data_gt[-folds[[i]],])
rmse <- sqrt(mean((phone_data_gt[-folds[[i]],]$gt - predictions)^2))
svm.accuracies = append(rmse, svm.accuracies)
}
return(svm.accuracies)
}
svm.accuracy <- crossval.svm(k = 10,
epsilon = tuneResult.eps.linear.gt$best.parameters$epsilon,
cost = tuneResult.eps.linear.gt$best.parameters$cost,
kernel = "linear",
type = "eps-regression")
mean(svm.accuracy)
crossval.svm <- function(k = 10, epsilon = 0.1, cost = 1, coef0 = 0, nu=0, kernel="radial",
type="eps-regression", data="gt"){
library(caret)
library(e1071)
if (data=="gt") {
data = phone_data_gt
set.seed(100)
folds <- createFolds(phone_data_gt[,c("gt")], k = k,
list = TRUE, returnTrain = FALSE)
formula <- gt~.
} else {
data = phone_data_pr
set.seed(100)
folds <- createFolds(phone_data_pr[,c("pr")], k = k,
list = TRUE, returnTrain = FALSE)
formula <- pr~.
}
svm.accuracies <- c()
for (i in 1:10) {
if (type=="eps-regression") {
model <- svm(formula, data[-folds[[i]],],
epsilon=epsilon,
cost=cost,
coef0=coef0,
type=type,
kernel=kernel
)
} else {
model <- svm(formula, data[-folds[[i]],],
nu=nu,
cost=cost,
coef0=coef0,
type=type,
kernel=kernel
)
}
print(model)
predictions <- predict(model, phone_data_gt[-folds[[i]],])
rmse <- sqrt(mean((phone_data_gt[-folds[[i]],]$gt - predictions)^2))
svm.accuracies = append(rmse, svm.accuracies)
}
return(svm.accuracies)
}
svm.accuracy <- crossval.svm(k = 10,
epsilon = tuneResult.eps.linear.gt$best.parameters$epsilon,
cost = tuneResult.eps.linear.gt$best.parameters$cost,
kernel = "linear",
type = "eps-regression")
mean(svm.accuracy)
svm.accuracy <- crossval.svm(k = 10,
epsilon = 0,
cost = 4,
kernel = "linear",
type = "eps-regression")
mean(svm.accuracy)
svm.accuracy <- crossval.svm(k = 10,
epsilon = 0,
cost = 4,
kernel = "linear",
type = "eps-regression")
mean(svm.accuracy)
svm.accuracy <- crossval.svm(k = 10,
epsilon = 0,
cost = 4,
kernel = "linear",
type = "eps-regression",
data="pr")
mean(svm.accuracy)
testing <- svm(gt.~, phone_data_gt)
testing <- svm(gt.~, data=phone_data_gt)
testing <- svm(gt~., phone_data_gt)
testing
testing <- svm(gt~., phone_data_gt, type="nu-regression")
testing
library(caret)
tuning_params <- expand.grid(parameter=seq(1,1,1))
set.seed(100)
linear.gt.stepwise <- train(gt~., data=phone_data_gt, method="leapSeq",
trControl=fit_control, tuneGrid = tuning_params)
fit_control <- trainControl(method = "repeatedcv", number = 10, repeats = 10)
library(caret)
tuning_params <- expand.grid(nvmax=seq(1,4,1))
set.seed(100)
linear.gt.forward <- train(gt~., data=phone_data_gt, method="leapForward",
trControl=fit_control, tuneGrid = tuning_params)
# linear stepwise selection
library(caret)
tuning_params <- expand.grid(parameter=seq(1,1,1))
set.seed(100)
linear.gt.stepwise <- train(gt~., data=phone_data_gt, method="leapSeq",
trControl=fit_control, tuneGrid = tuning_params)
library(caret)
tuning_params <- expand.grid(nvmax=seq(1,1,1))
set.seed(100)
linear.gt.stepwise <- train(gt~., data=phone_data_gt, method="leapSeq",
trControl=fit_control, tuneGrid = tuning_params)
tuning_params <- expand.grid(nvmax=seq(1,4,1))
set.seed(100)
linear.gt.stepwise <- train(gt~., data=phone_data_gt, method="leapSeq",
trControl=fit_control, tuneGrid = tuning_params)
linear.gt.stepwise
tuning_params <- expand.grid(nvmax=seq(1,4,1))
set.seed(100)
linear.gt.backward <- train(gt~., data=phone_data_gt, method="leapBackward",
trControl=fit_control, tuneGrid = tuning_params)
plotWithBars(linear.gt.backward)
plotWithBars <- function(model){
library(ggplot2)
foo <- model$results
title <- paste("The Performance of", knn.gt$modelInfo$label, sep=" ")
colnames(foo)[1] <- "params"
ggplot(foo, aes(x=params, y=RMSE)) +
geom_errorbar(aes(ymin=RMSE-RMSESD, ymax=RMSE+RMSESD), width=.1) +
geom_line() + geom_point()+ expand_limits(y = 0)+ theme_bw()+
xlab(model$modelInfo$parameters$label) +
ylab("RMSE (Repeated Cross-Validation)") +
ggtitle(title)
}
library(caret)
tuning_params <- expand.grid(nvmax=seq(1,4,1))
set.seed(100)
linear.gt.backward <- train(gt~., data=phone_data_gt, method="leapBackward",
trControl=fit_control, tuneGrid = tuning_params)
plotWithBars(linear.gt.backward)
plotWithBars <- function(model){
library(ggplot2)
foo <- model$results
title <- paste("The Performance of", model$modelInfo$label, sep=" ")
colnames(foo)[1] <- "params"
ggplot(foo, aes(x=params, y=RMSE)) +
geom_errorbar(aes(ymin=RMSE-RMSESD, ymax=RMSE+RMSESD), width=.1) +
geom_line() + geom_point()+ expand_limits(y = 0)+ theme_bw()+
xlab(model$modelInfo$parameters$label) +
ylab("RMSE (Repeated Cross-Validation)") +
ggtitle(title)
}
library(caret)
tuning_params <- expand.grid(nvmax=seq(1,4,1))
set.seed(100)
linear.gt.backward <- train(gt~., data=phone_data_gt, method="leapBackward",
trControl=fit_control, tuneGrid = tuning_params)
plotWithBars(linear.gt.backward)
linear.gt.backward
tuning_params <- expand.grid(nvmax=seq(1,4,1))
set.seed(100)
linear.gt.forward <- train(gt~., data=phone_data_gt, method="leapForward",
trControl=fit_control, tuneGrid = tuning_params)
plotWithBars(linear.gt.forward)
tuning_params <- expand.grid(nvmax=seq(1,4,1))
set.seed(100)
linear.pr.forward <- train(pr~., data=phone_data_pr, method="leapForward",
trControl=fit_control, tuneGrid = tuning_params)
plotWithBars(linear.pr.forward)
tuning_params <- expand.grid(nvmax=seq(1,4,1))
set.seed(100)
linear.gt.backward <- train(gt~., data=phone_data_gt, method="leapBackward",
trControl=fit_control, tuneGrid = tuning_params)
plotWithBars(linear.gt.backward)
tuning_params <- expand.grid(nvmax=seq(1,4,1))
set.seed(100)
linear.pr.forward <- train(pr~., data=phone_data_pr, method="leapBackward",
trControl=fit_control, tuneGrid = tuning_params)
plotWithBars(linear.pr.forward)
tuning_params <- expand.grid(nvmax=seq(1,4,1))
set.seed(100)
linear.gt.stepwise <- train(gt~., data=phone_data_gt, method="leapSeq",
trControl=fit_control, tuneGrid = tuning_params)
plotWithBars(linear.gt.stepwise)
linear.gt.stepwise
tuning_params <- expand.grid(nvmax=seq(1,4,1))
set.seed(100)
linear.pr.forward <- train(pr~., data=phone_data_pr, method="leapSeq",
trControl=fit_control, tuneGrid = tuning_params)
plotWithBars(linear.pr.forward)
library(caret)
fit_control <- trainControl(method = "repeatedcv", number = 10, repeats = 10)
tuning_params <- expand.grid(k=seq(1,30,1))
set.seed(100)
knn.gt <- train(gt~., data=phone_data_gt, method="knn",
trControl=fit_control, tuneGrid = tuning_params)
plotWithBars(knn.gt)
knn.gt
linear.pr.forward
fit_control <- trainControl(method = "repeatedcv", number = 10, repeats = 10)
tuning_params <- expand.grid(k=seq(1,30,1))
set.seed(100)
knn.pr <- train(pr~., data=phone_data_pr, method="knn",
trControl=fit_control, tuneGrid = tuning_params)
plotWithBars(knn.pr)
knn.pr
svm.accuracy <- crossval.svm(k = 10,
nu = tuneResult.nu.rad.gt$best.parameters$nu,
cost = tuneResult.nu.rad.gt$best.parameters$cost,
kernel = "radial",
type = "nu-regression")
mean(svm.accuracy)
crossval.svm <- function(k = 10, epsilon = 0.1, cost = 1, coef0 = 0, nu=0, kernel="radial",
type="eps-regression", data="gt"){
library(caret)
library(e1071)
if (data=="gt") {
df <- phone_data_gt
set.seed(100)
folds <- createFolds(phone_data_gt[,c("gt")], k = k,
list = TRUE, returnTrain = FALSE)
formula <- gt~.
} else {
df <- phone_data_pr
set.seed(100)
folds <- createFolds(phone_data_pr[,c("pr")], k = k,
list = TRUE, returnTrain = FALSE)
formula <- pr~.
}
svm.accuracies <- c()
for (i in 1:10) {
if (type=="eps-regression") {
model <- svm(formula, df[-folds[[i]],],
epsilon=epsilon,
cost=cost,
coef0=coef0,
type=type,
kernel=kernel
)
} else {
model <- svm(formula, df[-folds[[i]],],
nu=nu,
cost=cost,
coef0=coef0,
type=type,
kernel=kernel
)
}
if (data=="gt") {
predictions <- predict(model, phone_data_gt[-folds[[i]],])
rmse <- sqrt(mean((phone_data_gt[-folds[[i]],]$gt - predictions)^2))
svm.accuracies = append(rmse, svm.accuracies)
} else {
predictions <- predict(model, phone_data_pr[-folds[[i]],])
rmse <- sqrt(mean((phone_data_pr[-folds[[i]],]$pr - predictions)^2))
svm.accuracies = append(rmse, svm.accuracies)
}
}
return(svm.accuracies)
}
svm.accuracy <- crossval.svm(k = 10,
nu = tuneResult.nu.rad.gt$best.parameters$nu,
cost = tuneResult.nu.rad.gt$best.parameters$cost,
kernel = "radial",
type = "nu-regression")
mean(svm.accuracy)
svm.accuracy <- crossval.svm(k = 10,
nu = tuneResult.nu.rad.gt$best.parameters$nu,
cost = 1000,
kernel = "radial",
type = "nu-regression")
svm.accuracy <- crossval.svm(k = 10,
epsilon = tuneResult.eps.rad.gt$best.parameters$epsilon,
cost = tuneResult.eps.rad.gt$best.parameters$cost,
kernel = "radial",
type = "eps-regression")
mean(svm.accuracy)
svm.accuracy <- crossval.svm(k = 10,
epsilon = tuneResult.eps.rad.gt$best.parameters$epsilon,
cost = 1000,
kernel = "radial",
type = "eps-regression")
mean(svm.accuracy)
sd(svm.accuracy)
highCmean <- c()
highCsd <- c()
svm.accuracy <- crossval.svm(k = 10,
epsilon = tuneResult.eps.rad.gt$best.parameters$epsilon,
cost = 1000,
kernel = "radial",
type = "eps-regression")
mean(svm.accuracy)
sd(svm.accuracy)
highCmean <- append(mean(svm.accuracy), highCmean)
highCsd <- append(sd(svm.accuracy), highCsd)
svm.accuracy <- crossval.svm(k = 10,
epsilon = tuneResult.eps.rad.gt$best.parameters$epsilon,
cost = 2000,
kernel = "radial",
type = "eps-regression")
mean(svm.accuracy)
sd(svm.accuracy)
highCmean <- append(mean(svm.accuracy), highCmean)
highCsd <- append(sd(svm.accuracy), highCsd)
svm.accuracy <- crossval.svm(k = 10,
epsilon = tuneResult.eps.rad.gt$best.parameters$epsilon,
cost = 3000,
kernel = "radial",
type = "eps-regression")
mean(svm.accuracy)
sd(svm.accuracy)
highCmean <- append(mean(svm.accuracy), highCmean)
highCsd <- append(sd(svm.accuracy), highCsd)
highC <- c(1000,2000,3000,10000,100000)
svm.accuracy <- crossval.svm(k = 10,
epsilon = tuneResult.eps.rad.gt$best.parameters$epsilon,
cost = 10000,
kernel = "radial",
type = "eps-regression")
mean(svm.accuracy)
sd(svm.accuracy)
highCmean <- append(mean(svm.accuracy), highCmean)
highCsd <- append(sd(svm.accuracy), highCsd)
svm.accuracy <- crossval.svm(k = 10,
epsilon = tuneResult.eps.rad.gt$best.parameters$epsilon,
cost = 100000,
kernel = "radial",
type = "eps-regression")
mean(svm.accuracy)
sd(svm.accuracy)
highCmean <- append(mean(svm.accuracy), highCmean)
highCsd <- append(sd(svm.accuracy), highCsd)
ggplot(highC, highCmean)
ggplot(aes(x=highC, y=highCmean))
df <- data.frame(highC, highCmean, highCsd)
df
ggplot(df, aes(x=highC, y=highCmean))
ggplot(df, aes(x=highC, y=highCmean)) +
geom_errorbar(aes(ymin=highCmean-highCsd, ymax=highCmean+highCsd), width=.1) +
geom_line() + geom_point()+ expand_limits(y = 0)+ theme_bw()
highC <- c(100000,10000,3000,2000,1000)
df <- data.frame(highC, highCmean, highCsd)
ggplot(df, aes(x=highC, y=highCmean)) +
geom_errorbar(aes(ymin=highCmean-highCsd, ymax=highCmean+highCsd), width=.1) +
geom_line() + geom_point()+ expand_limits(y = 0)+ theme_bw()
ggplot(df, aes(x=highC, y=highCmean)) +
geom_errorbar(aes(ymin=highCmean-highCsd, ymax=highCmean+highCsd), width=.1) +
geom_line() + geom_point()+ expand_limits(y = 0)+ theme_bw()+
xlab(Cost) +
ylab("RMSE (Cross-Validation)")
ggplot(df, aes(x=highC, y=highCmean)) +
geom_errorbar(aes(ymin=highCmean-highCsd, ymax=highCmean+highCsd), width=.1) +
geom_line() + geom_point()+ expand_limits(y = 0)+ theme_bw()+
xlab("Cost") +
ylab("RMSE (Cross-Validation)")
